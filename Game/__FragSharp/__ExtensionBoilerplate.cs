// This file was auto-generated by FragSharp. It will be regenerated on the next compilation.
// Manual changes made will not persist and may cause incorrect behavior between compilations.

using System;
using System.Collections.Generic;

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

using FragSharpFramework;

namespace Game
{
    [Hlsl("float4")]
    public partial struct corpse : Convertible<vec4, corpse>
    {
        public corpse ConvertFrom(vec4 v)
        {
            return (corpse)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public corpse(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static corpse operator *(float a, corpse v)
        {
            return new corpse(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static corpse operator *(corpse v, float a)
        {
            return new corpse(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static corpse operator /(float a, corpse v)
        {
            return new corpse(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static corpse operator /(corpse v, float a)
        {
            return new corpse(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static corpse operator +(corpse v, corpse w)
        {
            return new corpse(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static corpse operator -(corpse v, corpse w)
        {
            return new corpse(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static corpse operator *(corpse v, corpse w)
        {
            return new corpse(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static corpse operator /(corpse v, corpse w)
        {
            return new corpse(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(corpse v, corpse w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(corpse v, corpse w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is corpse ? this == (corpse)o : false;
        }

        public bool Equals(corpse v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static corpse operator -(corpse v)
        {
            return new corpse(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(corpse v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator corpse(color v)
        {
            return new corpse(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(corpse v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator corpse(Vector4 v)
        {
            return new corpse(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(corpse v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly corpse Zero    = new corpse(0, 0, 0, 0);
        public static readonly corpse Nothing = new corpse(0, 0, 0, 0);

        public static explicit operator corpse(vec4 v) { return new corpse(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(corpse v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct tile : Convertible<vec4, tile>
    {
        public tile ConvertFrom(vec4 v)
        {
            return (tile)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public tile(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static tile operator *(float a, tile v)
        {
            return new tile(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static tile operator *(tile v, float a)
        {
            return new tile(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static tile operator /(float a, tile v)
        {
            return new tile(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static tile operator /(tile v, float a)
        {
            return new tile(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static tile operator +(tile v, tile w)
        {
            return new tile(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static tile operator -(tile v, tile w)
        {
            return new tile(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static tile operator *(tile v, tile w)
        {
            return new tile(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static tile operator /(tile v, tile w)
        {
            return new tile(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(tile v, tile w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(tile v, tile w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is tile ? this == (tile)o : false;
        }

        public bool Equals(tile v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static tile operator -(tile v)
        {
            return new tile(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(tile v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator tile(color v)
        {
            return new tile(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(tile v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator tile(Vector4 v)
        {
            return new tile(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(tile v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly tile Zero    = new tile(0, 0, 0, 0);
        public static readonly tile Nothing = new tile(0, 0, 0, 0);

        public static explicit operator tile(vec4 v) { return new tile(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(tile v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct magic : Convertible<vec4, magic>
    {
        public magic ConvertFrom(vec4 v)
        {
            return (magic)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public magic(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static magic operator *(float a, magic v)
        {
            return new magic(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static magic operator *(magic v, float a)
        {
            return new magic(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static magic operator /(float a, magic v)
        {
            return new magic(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static magic operator /(magic v, float a)
        {
            return new magic(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static magic operator +(magic v, magic w)
        {
            return new magic(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static magic operator -(magic v, magic w)
        {
            return new magic(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static magic operator *(magic v, magic w)
        {
            return new magic(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static magic operator /(magic v, magic w)
        {
            return new magic(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(magic v, magic w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(magic v, magic w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is magic ? this == (magic)o : false;
        }

        public bool Equals(magic v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static magic operator -(magic v)
        {
            return new magic(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(magic v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator magic(color v)
        {
            return new magic(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(magic v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator magic(Vector4 v)
        {
            return new magic(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(magic v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly magic Zero    = new magic(0, 0, 0, 0);
        public static readonly magic Nothing = new magic(0, 0, 0, 0);

        public static explicit operator magic(vec4 v) { return new magic(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(magic v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct geo : Convertible<vec4, geo>
    {
        public geo ConvertFrom(vec4 v)
        {
            return (geo)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public geo(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static geo operator *(float a, geo v)
        {
            return new geo(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static geo operator *(geo v, float a)
        {
            return new geo(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static geo operator /(float a, geo v)
        {
            return new geo(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static geo operator /(geo v, float a)
        {
            return new geo(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static geo operator +(geo v, geo w)
        {
            return new geo(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static geo operator -(geo v, geo w)
        {
            return new geo(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static geo operator *(geo v, geo w)
        {
            return new geo(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static geo operator /(geo v, geo w)
        {
            return new geo(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(geo v, geo w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(geo v, geo w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is geo ? this == (geo)o : false;
        }

        public bool Equals(geo v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static geo operator -(geo v)
        {
            return new geo(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(geo v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator geo(color v)
        {
            return new geo(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(geo v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator geo(Vector4 v)
        {
            return new geo(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(geo v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly geo Zero    = new geo(0, 0, 0, 0);
        public static readonly geo Nothing = new geo(0, 0, 0, 0);

        public static explicit operator geo(vec4 v) { return new geo(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(geo v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct dirward : Convertible<vec4, dirward>
    {
        public dirward ConvertFrom(vec4 v)
        {
            return (dirward)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public dirward(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static dirward operator *(float a, dirward v)
        {
            return new dirward(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static dirward operator *(dirward v, float a)
        {
            return new dirward(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static dirward operator /(float a, dirward v)
        {
            return new dirward(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static dirward operator /(dirward v, float a)
        {
            return new dirward(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static dirward operator +(dirward v, dirward w)
        {
            return new dirward(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static dirward operator -(dirward v, dirward w)
        {
            return new dirward(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static dirward operator *(dirward v, dirward w)
        {
            return new dirward(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static dirward operator /(dirward v, dirward w)
        {
            return new dirward(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(dirward v, dirward w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(dirward v, dirward w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is dirward ? this == (dirward)o : false;
        }

        public bool Equals(dirward v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static dirward operator -(dirward v)
        {
            return new dirward(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(dirward v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator dirward(color v)
        {
            return new dirward(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(dirward v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator dirward(Vector4 v)
        {
            return new dirward(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(dirward v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly dirward Zero    = new dirward(0, 0, 0, 0);
        public static readonly dirward Nothing = new dirward(0, 0, 0, 0);

        public static explicit operator dirward(vec4 v) { return new dirward(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(dirward v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct geo_info : Convertible<vec4, geo_info>
    {
        public geo_info ConvertFrom(vec4 v)
        {
            return (geo_info)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public geo_info(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static geo_info operator *(float a, geo_info v)
        {
            return new geo_info(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static geo_info operator *(geo_info v, float a)
        {
            return new geo_info(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static geo_info operator /(float a, geo_info v)
        {
            return new geo_info(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static geo_info operator /(geo_info v, float a)
        {
            return new geo_info(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static geo_info operator +(geo_info v, geo_info w)
        {
            return new geo_info(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static geo_info operator -(geo_info v, geo_info w)
        {
            return new geo_info(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static geo_info operator *(geo_info v, geo_info w)
        {
            return new geo_info(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static geo_info operator /(geo_info v, geo_info w)
        {
            return new geo_info(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(geo_info v, geo_info w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(geo_info v, geo_info w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is geo_info ? this == (geo_info)o : false;
        }

        public bool Equals(geo_info v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static geo_info operator -(geo_info v)
        {
            return new geo_info(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(geo_info v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator geo_info(color v)
        {
            return new geo_info(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(geo_info v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator geo_info(Vector4 v)
        {
            return new geo_info(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(geo_info v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly geo_info Zero    = new geo_info(0, 0, 0, 0);
        public static readonly geo_info Nothing = new geo_info(0, 0, 0, 0);

        public static explicit operator geo_info(vec4 v) { return new geo_info(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(geo_info v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct unit : Convertible<vec4, unit>
    {
        public unit ConvertFrom(vec4 v)
        {
            return (unit)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public unit(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static unit operator *(float a, unit v)
        {
            return new unit(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static unit operator *(unit v, float a)
        {
            return new unit(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static unit operator /(float a, unit v)
        {
            return new unit(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static unit operator /(unit v, float a)
        {
            return new unit(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static unit operator +(unit v, unit w)
        {
            return new unit(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static unit operator -(unit v, unit w)
        {
            return new unit(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static unit operator *(unit v, unit w)
        {
            return new unit(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static unit operator /(unit v, unit w)
        {
            return new unit(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(unit v, unit w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(unit v, unit w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is unit ? this == (unit)o : false;
        }

        public bool Equals(unit v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static unit operator -(unit v)
        {
            return new unit(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(unit v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator unit(color v)
        {
            return new unit(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(unit v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator unit(Vector4 v)
        {
            return new unit(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(unit v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly unit Zero    = new unit(0, 0, 0, 0);
        public static readonly unit Nothing = new unit(0, 0, 0, 0);

        public static explicit operator unit(vec4 v) { return new unit(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(unit v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct data : Convertible<vec4, data>
    {
        public data ConvertFrom(vec4 v)
        {
            return (data)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public data(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static data operator *(float a, data v)
        {
            return new data(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static data operator *(data v, float a)
        {
            return new data(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static data operator /(float a, data v)
        {
            return new data(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static data operator /(data v, float a)
        {
            return new data(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static data operator +(data v, data w)
        {
            return new data(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static data operator -(data v, data w)
        {
            return new data(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static data operator *(data v, data w)
        {
            return new data(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static data operator /(data v, data w)
        {
            return new data(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(data v, data w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(data v, data w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is data ? this == (data)o : false;
        }

        public bool Equals(data v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static data operator -(data v)
        {
            return new data(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(data v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator data(color v)
        {
            return new data(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(data v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator data(Vector4 v)
        {
            return new data(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(data v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly data Zero    = new data(0, 0, 0, 0);
        public static readonly data Nothing = new data(0, 0, 0, 0);

        public static explicit operator data(vec4 v) { return new data(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(data v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct building : Convertible<vec4, building>
    {
        public building ConvertFrom(vec4 v)
        {
            return (building)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public building(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static building operator *(float a, building v)
        {
            return new building(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static building operator *(building v, float a)
        {
            return new building(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static building operator /(float a, building v)
        {
            return new building(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static building operator /(building v, float a)
        {
            return new building(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static building operator +(building v, building w)
        {
            return new building(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static building operator -(building v, building w)
        {
            return new building(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static building operator *(building v, building w)
        {
            return new building(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static building operator /(building v, building w)
        {
            return new building(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(building v, building w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(building v, building w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is building ? this == (building)o : false;
        }

        public bool Equals(building v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static building operator -(building v)
        {
            return new building(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(building v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator building(color v)
        {
            return new building(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(building v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator building(Vector4 v)
        {
            return new building(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(building v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly building Zero    = new building(0, 0, 0, 0);
        public static readonly building Nothing = new building(0, 0, 0, 0);

        public static explicit operator building(vec4 v) { return new building(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(building v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct extra : Convertible<vec4, extra>
    {
        public extra ConvertFrom(vec4 v)
        {
            return (extra)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public extra(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static extra operator *(float a, extra v)
        {
            return new extra(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static extra operator *(extra v, float a)
        {
            return new extra(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static extra operator /(float a, extra v)
        {
            return new extra(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static extra operator /(extra v, float a)
        {
            return new extra(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static extra operator +(extra v, extra w)
        {
            return new extra(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static extra operator -(extra v, extra w)
        {
            return new extra(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static extra operator *(extra v, extra w)
        {
            return new extra(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static extra operator /(extra v, extra w)
        {
            return new extra(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(extra v, extra w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(extra v, extra w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is extra ? this == (extra)o : false;
        }

        public bool Equals(extra v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static extra operator -(extra v)
        {
            return new extra(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(extra v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator extra(color v)
        {
            return new extra(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(extra v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator extra(Vector4 v)
        {
            return new extra(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(extra v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly extra Zero    = new extra(0, 0, 0, 0);
        public static readonly extra Nothing = new extra(0, 0, 0, 0);

        public static explicit operator extra(vec4 v) { return new extra(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(extra v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct BuildingDist : Convertible<vec4, BuildingDist>
    {
        public BuildingDist ConvertFrom(vec4 v)
        {
            return (BuildingDist)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public BuildingDist(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static BuildingDist operator *(float a, BuildingDist v)
        {
            return new BuildingDist(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static BuildingDist operator *(BuildingDist v, float a)
        {
            return new BuildingDist(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static BuildingDist operator /(float a, BuildingDist v)
        {
            return new BuildingDist(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static BuildingDist operator /(BuildingDist v, float a)
        {
            return new BuildingDist(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static BuildingDist operator +(BuildingDist v, BuildingDist w)
        {
            return new BuildingDist(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static BuildingDist operator -(BuildingDist v, BuildingDist w)
        {
            return new BuildingDist(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static BuildingDist operator *(BuildingDist v, BuildingDist w)
        {
            return new BuildingDist(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static BuildingDist operator /(BuildingDist v, BuildingDist w)
        {
            return new BuildingDist(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(BuildingDist v, BuildingDist w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(BuildingDist v, BuildingDist w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is BuildingDist ? this == (BuildingDist)o : false;
        }

        public bool Equals(BuildingDist v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static BuildingDist operator -(BuildingDist v)
        {
            return new BuildingDist(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(BuildingDist v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator BuildingDist(color v)
        {
            return new BuildingDist(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(BuildingDist v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator BuildingDist(Vector4 v)
        {
            return new BuildingDist(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(BuildingDist v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly BuildingDist Zero    = new BuildingDist(0, 0, 0, 0);
        public static readonly BuildingDist Nothing = new BuildingDist(0, 0, 0, 0);

        public static explicit operator BuildingDist(vec4 v) { return new BuildingDist(v.x, v.y, v.z, v.w); }
        public static explicit operator vec4(BuildingDist v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct ActionCount : Convertible<vec4, ActionCount>
    {
        public ActionCount ConvertFrom(vec4 v)
        {
            return (ActionCount)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public ActionCount(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static ActionCount operator *(float a, ActionCount v)
        {
            return new ActionCount(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static ActionCount operator *(ActionCount v, float a)
        {
            return new ActionCount(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static ActionCount operator /(float a, ActionCount v)
        {
            return new ActionCount(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static ActionCount operator /(ActionCount v, float a)
        {
            return new ActionCount(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static ActionCount operator +(ActionCount v, ActionCount w)
        {
            return new ActionCount(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static ActionCount operator -(ActionCount v, ActionCount w)
        {
            return new ActionCount(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static ActionCount operator *(ActionCount v, ActionCount w)
        {
            return new ActionCount(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static ActionCount operator /(ActionCount v, ActionCount w)
        {
            return new ActionCount(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(ActionCount v, ActionCount w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(ActionCount v, ActionCount w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is ActionCount ? this == (ActionCount)o : false;
        }

        public bool Equals(ActionCount v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static ActionCount operator -(ActionCount v)
        {
            return new ActionCount(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(ActionCount v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator ActionCount(color v)
        {
            return new ActionCount(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(ActionCount v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator ActionCount(Vector4 v)
        {
            return new ActionCount(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(ActionCount v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly ActionCount Zero    = new ActionCount(0, 0, 0, 0);
        public static readonly ActionCount Nothing = new ActionCount(0, 0, 0, 0);

        public static implicit operator ActionCount(vec4 v) { return new ActionCount(v.x, v.y, v.z, v.w); }
        public static implicit operator vec4(ActionCount v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct PlayerTuple : Convertible<vec4, PlayerTuple>
    {
        public PlayerTuple ConvertFrom(vec4 v)
        {
            return (PlayerTuple)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public PlayerTuple(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static PlayerTuple operator *(float a, PlayerTuple v)
        {
            return new PlayerTuple(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static PlayerTuple operator *(PlayerTuple v, float a)
        {
            return new PlayerTuple(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static PlayerTuple operator /(float a, PlayerTuple v)
        {
            return new PlayerTuple(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static PlayerTuple operator /(PlayerTuple v, float a)
        {
            return new PlayerTuple(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static PlayerTuple operator +(PlayerTuple v, PlayerTuple w)
        {
            return new PlayerTuple(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static PlayerTuple operator -(PlayerTuple v, PlayerTuple w)
        {
            return new PlayerTuple(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static PlayerTuple operator *(PlayerTuple v, PlayerTuple w)
        {
            return new PlayerTuple(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static PlayerTuple operator /(PlayerTuple v, PlayerTuple w)
        {
            return new PlayerTuple(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(PlayerTuple v, PlayerTuple w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(PlayerTuple v, PlayerTuple w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is PlayerTuple ? this == (PlayerTuple)o : false;
        }

        public bool Equals(PlayerTuple v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static PlayerTuple operator -(PlayerTuple v)
        {
            return new PlayerTuple(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(PlayerTuple v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator PlayerTuple(color v)
        {
            return new PlayerTuple(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(PlayerTuple v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator PlayerTuple(Vector4 v)
        {
            return new PlayerTuple(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(PlayerTuple v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly PlayerTuple Zero    = new PlayerTuple(0, 0, 0, 0);
        public static readonly PlayerTuple Nothing = new PlayerTuple(0, 0, 0, 0);

        public static implicit operator PlayerTuple(vec4 v) { return new PlayerTuple(v.x, v.y, v.z, v.w); }
        public static implicit operator vec4(PlayerTuple v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

namespace Game
{
    [Hlsl("float4")]
    public partial struct TeamTuple : Convertible<vec4, TeamTuple>
    {
        public TeamTuple ConvertFrom(vec4 v)
        {
            return (TeamTuple)v;
        }

        public vec4 ConvertTo()
        {
            return (vec4)this;
        }

        [Hlsl("float4")]
        public TeamTuple(float x, float y, float z, float w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        [Hlsl("x")]
        public float x;

        [Hlsl("y")]
        public float y;

        [Hlsl("z")]
        public float z;

        [Hlsl("w")]
        public float w;

        [Hlsl("xy")]
        public vec2 xy { get { return new vec2(x, y); } set { x = value.x; y = value.y; } }

        [Hlsl("zw")]
        public vec2 zw { get { return new vec2(z, w); } set { z = value.x; w = value.y; } }

        [Hlsl("xyz")]
        public vec3 xyz { get { return new vec3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        [Hlsl("yzw")]
        public vec3 yzw { get { return new vec3(y, z, w); } set { y = value.x; z = value.y; w = value.z; } }

        [Hlsl("r")]
        public float r { get { return x; } set { x = value; } }

        [Hlsl("g")]
        public float g { get { return y; } set { y = value; } }

        [Hlsl("b")]
        public float b { get { return z; } set { z = value; } }

        [Hlsl("a")]
        public float a { get { return w; } set { w = value; } }

        [Hlsl("rgb")]
        public vec3 rgb { get { return xyz; } set { xyz = value; } }

        [Hlsl("gba")]
        public vec3 gba { get { return yzw; } set { yzw = value; } }

        [Hlsl("rg")]
        public vec2 rg { get { return xy; } set { xy = value; } }

        [Hlsl("ba")]
        public vec2 ba { get { return zw; } set { zw = value; } }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    case 3: return w;
                    default: throw new Exception("Invalid index.");
                }
            }
        }

        public static TeamTuple operator *(float a, TeamTuple v)
        {
            return new TeamTuple(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static TeamTuple operator *(TeamTuple v, float a)
        {
            return new TeamTuple(a * v.x, a * v.y, a * v.z, a * v.w);
        }

        public static TeamTuple operator /(float a, TeamTuple v)
        {
            return new TeamTuple(a / v.x, a / v.y, a / v.z, a / v.w);
        }

        public static TeamTuple operator /(TeamTuple v, float a)
        {
            return new TeamTuple(v.x / a, v.y / a, v.z / a, v.w / a);
        }

        public static TeamTuple operator +(TeamTuple v, TeamTuple w)
        {
            return new TeamTuple(v.x + w.x, v.y + w.y, v.z + w.z, v.w + w.w);
        }

        public static TeamTuple operator -(TeamTuple v, TeamTuple w)
        {
            return new TeamTuple(v.x - w.x, v.y - w.y, v.z - w.z, v.w - w.w);
        }

        public static TeamTuple operator *(TeamTuple v, TeamTuple w)
        {
            return new TeamTuple(v.x * w.x, v.y * w.y, v.z * w.z, v.w * w.w);
        }

        public static TeamTuple operator /(TeamTuple v, TeamTuple w)
        {
            return new TeamTuple(v.x / w.x, v.y / w.y, v.z / w.z, v.w / w.w);
        }

        public static bool operator ==(TeamTuple v, TeamTuple w)
        {
            return
                v.x == w.x &&
                v.y == w.y &&
                v.z == w.z &&
                v.w == w.w;
        }

        public static bool operator !=(TeamTuple v, TeamTuple w)
        {
            return
                v.x != w.x ||
                v.y != w.y ||
                v.z != w.z ||
                v.w != w.w;
        }

        public override bool Equals(object o)
        {
            return o is TeamTuple ? this == (TeamTuple)o : false;
        }

        public bool Equals(TeamTuple v)
        {
            return this == v;
        }

        public override int GetHashCode()
        {
            return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode() ^ w.GetHashCode();
        }

        public static TeamTuple operator -(TeamTuple v)
        {
            return new TeamTuple(-v.x, -v.y, -v.z, -v.w);
        }

        public static implicit operator Vector4(TeamTuple v)
        {
            return new Vector4(v.x, v.y, v.z, v.w);
        }

        public static implicit operator TeamTuple(color v)
        {
            return new TeamTuple(v.x, v.y, v.z, v.w);
        }

        public static explicit operator color(TeamTuple v)
        {
            return new color(v.x, v.y, v.z, v.w);
        }

        public static explicit operator TeamTuple(Vector4 v)
        {
            return new TeamTuple(v.X, v.Y, v.Z, v.W);
        }

        public static explicit operator Color(TeamTuple v)
        {
            return new Color(v.x, v.y, v.z, v.w);
        }        

        public static readonly TeamTuple Zero    = new TeamTuple(0, 0, 0, 0);
        public static readonly TeamTuple Nothing = new TeamTuple(0, 0, 0, 0);

        public static implicit operator TeamTuple(vec4 v) { return new TeamTuple(v.x, v.y, v.z, v.w); }
        public static implicit operator vec4(TeamTuple v) { return new vec4(v.x, v.y, v.z, v.w); }
    }
}

